/*----------------------------------------------------------------------------*/
/* Copyright (c) FIRST 2008. All Rights Reserved.                             */
/* Open Source Software - may be modified and shared by FRC teams. The code   */
/* must be accompanied by the FIRST BSD license file in the root directory of */
/* the project.                                                               */
/*----------------------------------------------------------------------------*/

package edu.wpi.first.wpilibj.templates;

import edu.wpi.first.wpilibj.IterativeRobot;

import NerdHerd.Sensor.NerdyCompass;
import NerdHerd.Sensor.NerdyGyro;
import NerdHerd.Sensor.NerdyAccel;
import com.sun.squawk.util.MathUtils;
import edu.wpi.first.wpilibj.CANJaguar;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Timer;



/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
public class NerdyPIDRobot extends IterativeRobot{

    private double headingTolerance, distanceTolerance;
    private double error, desiredAngle;
    private double turnSpeed, joystickYMagnitude, ltPower, rtPower;
    private double headingOffset = 0;
    private double heading = 0;
    private double linearPower, angularPower;
    private double PIDOutputLinear, PIDOutputAngular;
    private double distanceTraveled = 0;
    private int PIincrement = 0;
    private NerdyCompass Compass;
    private NerdyAccel Accel;
    private NerdyGyro Gyro;
    private Joystick JoystickMain;
    private CANJaguar LtDriveMain, LtDriveSub, RtDriveMain, RtDriveSub;
    
            
    public void init(){
    try{
        LtDriveMain = new CANJaguar(1);
        LtDriveSub = new CANJaguar(3);
        RtDriveMain = new CANJaguar(2);
        RtDriveSub = new CANJaguar(4);
        }catch(Exception e){
        
        System.out.println(e);
        }
        
        JoystickMain = new Joystick(1);
        
        Compass.init();
        Accel.init();
        Gyro.init();
        
        Compass.read();
        Accel.read();
        Gyro.read();
        
        headingOffset = calcHeadingNTC();
    }
    
    public void setHeadingTolerance(double degree){
        headingTolerance = degree;
    }
    
    public double getHeadingTolerance(){
        return headingTolerance;
    }
    
    public boolean isHeadingTolerable(double desiredAngle){
        getHeading();
        return ((desiredAngle < heading+headingTolerance) && (desiredAngle > heading-headingTolerance));
    }
    
    public double getHeading(){
        return heading;
    }
    
    public void setDistanceTolerance(double degree){
        distanceTolerance = degree;
    }
    
    public double getDistanceTolerance(){
        return distanceTolerance;
    }
    
    public boolean isDistanceTolerable(double desiredDistance){
        getHeading();
        return ((desiredDistance < distanceTraveled+distanceTolerance) && (desiredDistance > distanceTraveled-distanceTolerance));
    }
    
    public double updateDistanceTraveled(){
        
        return distanceTraveled;
    }
    
    
    public double get360JoystickAngle(){
        double y = JoystickMain.getY();
        double x = JoystickMain.getX();
        double angle = MathUtils.atan(x/y) * 180 / Math.PI;  
        if (x >= 0){
            if (y >= 0){
                angle = 360 - angle;
            } else {
                angle = 180 - angle;
            }
        } else {
            if (y >= 0){
                angle = -angle;
            } else {
                angle = 180 - angle; 
            }
        }
        return angle%360;
    }
    
    private double calcHeadingNTC(){//Non-Tilt Compensated Compass
        Compass.read();
        int xAxisCompass = Compass.getAxisX();
        int yAxisCompass = Compass.getAxisY();
        heading = MathUtils.atan(yAxisCompass/xAxisCompass) - headingOffset;
        return heading;
    }
    
    private double calcHeadingTC(){  //Tilt Compensated Compass
        Accel.read();
        Compass.read();
        int xAxisAccel = Accel.getAxisX();
        int yAxisAccel = Accel.getAxisY();
        int xAxisCompass = Compass.getAxisX();
        int yAxisCompass = Compass.getAxisY();
        int zAxisCompass = Compass.getAxisZ();
        
        double pitch = MathUtils.asin(yAxisAccel);
        double roll = MathUtils.asin(xAxisAccel);
        double CMy = xAxisCompass*Math.cos(pitch) + zAxisCompass*Math.sin(pitch);
        double CMx = xAxisCompass*Math.sin(roll) + yAxisCompass*Math.sin(roll)*Math.cos(roll) - zAxisCompass*Math.sin(roll)*Math.cos(pitch);
        heading = MathUtils.atan(CMy/CMx) - headingOffset;
        return heading;
    }

    private double gyroCompassHeading(){
        double time = ;//Make time a constant.
        heading = (heading + Gyro.getAxisZ()*time) % 360;
        return heading;
    }
    
    private void calcShortestRotation(){
        error = desiredAngle - heading;

        if (Math.abs(error) >  180){
            error = -sign(error)*(360 - Math.abs(error));
        }
    }   
    
    public double GetPIDOutputAngular(double desiredAngle){
        calcShortestRotation();
        
        
        double PIDOutputAngular = error  ; 
        return PIDOutputAngular;
        
    }
    
    public double getPIDOutputLinear(double distance){
        
        PIDOutputLinear = 0;
        return PIDOutputLinear;
    }
    
    public void MoveAndRotate(double desiredAngle, double linearPower){
        //desiredAngle = get360JoystickAngle();
        //linearPower = JoystickMain.getY();
       
            if (isHeadingTolerable(desiredAngle)){
                ltPower = linearPower;
                rtPower = linearPower;
            } else {
                angularPower = GetPIDOutputAngular(desiredAngle);
                ltPower = turnSpeed*0.5 + linearPower*0.5;
                rtPower = turnSpeed*0.5 + linearPower*0.5;
            }
            try{
                LtDriveMain.set(ltPower);
                LtDriveMain.set(ltPower);
                RtDriveMain.set(rtPower);
                RtDriveMain.set(rtPower);
            }catch (Exception e){
                System.out.println(e);
            }
    }
    
    public void RotateRate(){
        angularPower = JoystickMain.getTwist();
        try{
            LtDriveMain.set(angularPower);
            LtDriveSub.set(angularPower);
            RtDriveMain.set(-angularPower);
            RtDriveSub.set(-angularPower);
        }catch (Exception e){
            System.out.println(e);
        }
        
    }
    
        public void RotateAngle(double desiredAngle){
        
            angularPower = GetPIDOutputAngular(desiredAngle);
        try{
            LtDriveMain.set(angularPower);
            LtDriveSub.set(angularPower);
            RtDriveMain.set(-angularPower);
            RtDriveSub.set(-angularPower);
        }catch (Exception e){
            System.out.println(e);
        }
        
    }
        
    private int sign(double number){
        
        if (number > 0){
            return 1;
        }else if (number < 0){
            return -1;
        } else {
            return 0;
        }
    }
}

/*----------------------------------------------------------------------------*/
/* Copyright (c) FIRST 2008. All Rights Reserved.                             */
/* Open Source Software - may be modified and shared by FRC teams. The code   */
/* must be accompanied by the FIRST BSD license file in the root directory of */
/* the project.                                                               */
/*----------------------------------------------------------------------------*/

package edu.wpi.first.wpilibj.templates;

import edu.wpi.first.wpilibj.IterativeRobot;

import NerdHerd.Sensor.NerdyCompass;
import NerdHerd.Sensor.NerdyGyro;
import NerdHerd.Sensor.NerdyAccel;
import com.sun.squawk.util.MathUtils;
import edu.wpi.first.wpilibj.CANJaguar;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Timer;



/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
public class NerdyPIDRobot extends IterativeRobot{

    private double headingTolerance, distanceTolerance;
    private double error;
    private double turnSpeed, ltPower, rtPower;
    private double headingOffset = 0;
    private double heading = 0;
    private double distanceTraveled = 0;
    
    private NerdyCompass Compass;
    private NerdyAccel Accel;
    private NerdyGyro Gyro;
    public Joystick JoystickMain;
    public CANJaguar LtDriveMain, LtDriveSub, RtDriveMain, RtDriveSub;
    
            
    public void init(){
    
    /*
    This function runs at the start of autonomous.
    It initializes the motors, Joystick, and 9dof sensor.
    It also does calculations to check for and elimate bias.
    */
    
        try{
            LtDriveMain = new CANJaguar(1);
            LtDriveSub = new CANJaguar(3);
            RtDriveMain = new CANJaguar(2);
            RtDriveSub = new CANJaguar(4);
        }catch(Exception e){
            System.out.println(e);
        }
        JoystickMain = new Joystick(1);
        Compass.init();
        Accel.init();
        Gyro.init();
        Compass.read();
        Accel.read();
        Gyro.read();
        headingOffset = calcHeadingNTC();
    }
    
    public void setHeadingTolerance(double degree){
    
    /*
    This sets a tolerance for the heading in degrees.
    Heading is tolerable if is + or - tolerance.
    Default is 0.
    */
    
        headingTolerance = degree;
    }
    
    public double getHeadingTolerance(){
    
    /*
    Returns heading tolerance in degrees. 
    If not set, this should return 0.
    */
    
        return headingTolerance;
    }
    
    public boolean isHeadingTolerable(double desiredAngle){
    
    /*
    Returns true if the heading is within the tolerance
    Otherwise returns false.
    */
    
        double lastHeading = getHeading();
        return ((desiredAngle < lastHeading+headingTolerance) && (desiredAngle > lastHeading-headingTolerance));
    }
    
    public double getHeading(){
    
    /*
    Returns the last updated Heading.
    Must use calcHeadingNTC(), calcHeadingTC(), or gyroCompassHeading() prior
    to get the most recent result.
    */
    
        return heading;
    }
    
    public void setDistanceTolerance(double meter){
    
    /*
    This sets a tolerance for the distance traveled in meters.
    Distance traveled is tolerable if is + or - tolerance.
    Default is 0.
    */
    
        distanceTolerance = meter;
    }
    
    public double getDistanceTolerance(){
    
    /*
    Returns heading tolerance in meters. 
    If not set, this should return 0.
    */
    
        return distanceTolerance;
    }
    
    public boolean isDistanceTolerable(double desiredDistance){
    
    /*
    Returns true if the distance traveled is within the tolerance
    Otherwise returns false.
    */
    
        double distance_Traveled = getDistance();
        return ((desiredDistance < distance_Traveled+distanceTolerance) && (desiredDistance > distance_Traveled-distanceTolerance));
    }
    
    public double getDistanceTraveled(){
    
    /*
    Returns the last updated distance traveled.
    Must use calcDistanceTraveled() prior to get the most recent result.
    */
    
        return distanceTraveled;
    }
    
    
    public double get360JoystickAngle(){
    
    /*
    Grabs an 360 degree angle reading from the joystick.
    0 degrees is north. 90 degrees is west.
    Should rewrite for arcade drive so that robot always faces forward.
    Should subtract Joystick Bias.
    */
    
        double y = -JoystickMain.getY();
        double x = JoystickMain.getX();
        double angle = MathUtils.atan(x/y) * 180 / Math.PI;  
        if (x == y == 0){
            //need heading update code
            return heading;
            }
        if (x >= 0){
            if (y >= 0){
                angle = 360 - angle;
            } else {
                angle = 180 - angle;
            }
        } else {
            if (y >= 0){
                angle = -angle;
            } else {
                angle = 180 - angle; 
            }
        }
        return angle%360;
    }
    
    private double calcHeadingNTC(){
    
    /*
    Updates and returns the heading.
    Heading is non-tilt compensated.
    Dependent on a working compass.
    */
    
        Compass.read();
        int xAxisCompass = Compass.getAxisX();
        int yAxisCompass = Compass.getAxisY();
        heading = MathUtils.atan(yAxisCompass/xAxisCompass) - headingOffset;
        return heading;
    }
    
    private double calcHeadingTC(){
    
    /*
    Updates and returns the heading.
    Heading is tilt compensated.
    Dependent on a working compass and accelerometer.
    This process will be more cpu intensive than other heading functions.
    */
    
        Accel.read();
        Compass.read();
        int xAxisAccel = Accel.getAxisX();
        int yAxisAccel = Accel.getAxisY();
        int xAxisCompass = Compass.getAxisX();
        int yAxisCompass = Compass.getAxisY();
        int zAxisCompass = Compass.getAxisZ();
        double pitch = MathUtils.asin(yAxisAccel);
        double roll = MathUtils.asin(xAxisAccel);
        double CMy = xAxisCompass*Math.cos(pitch) + zAxisCompass*Math.sin(pitch);
        double CMx = xAxisCompass*Math.sin(roll) + yAxisCompass*Math.sin(roll)*Math.cos(roll) - zAxisCompass*Math.sin(roll)*Math.cos(pitch);
        heading = MathUtils.atan(CMy/CMx) - headingOffset;
        return heading;
    }

    private double gyroCompassHeading(){
    
    /*
    Updates and returns the heading.
    Heading is not tilt compensated.
    Dependent on a working gyro. 
    */
    
        double time = ;//Make time a constant.
        heading = (heading + Gyro.getAxisZ()*time) % 360;
        return heading;
    }
    
    private void calcShortestRotation(double desiredAngle){
    
    /*
    Returns the degrees off between the desired angle and the heading.
    Must use calcHeadingNTC(), calcHeadingTC(), or gyroCompassHeading() prior
    to get the most recent result.
    */
    
        error = desiredAngle - heading;

        if (Math.abs(error) >  180){
            error = -sign(error)*(360 - Math.abs(error));
        }
        return error;
    }   
    
    public double GetPIDOutputAngular(double desiredAngle){
    
    /*
    Incomplete
    */
    
        calcShortestRotation();
        double PIDOutputAngular = error  ; 
        return PIDOutputAngular;
    }
    
    public double getPIDOutputLinear(double distance){
    
    /*
    Incomplete
    */
        
        double PIDOutputLinear = 0;
        return PIDOutputLinear;
    }
    
    public void MoveAndRotate(double desiredAngle, double linearPower){
       
    /*
    Rotates the wheels so that the robot faces the desired angle
    and travels at a set speed.
    To use in autonomous, set while loops checking if the distanceTraveled is not tolerable
    and if the heading is not tolerable. Include a if statement checking if the higher priority task
    is complete yet and a break in between. Pass in the vision results for desired heading and 
    the linearPower calculated from the getPIDOutputLinear() function.
    To use during teleop, set desired angle to the get360JoystickAngle() and the linearPower to 
    JoystickMain.getY();
    The 0.5s declaring the left and right powers can be changed as long as the sum is 1.0
    */
       
        if (isHeadingTolerable(desiredAngle)){
            ltPower = linearPower;
            rtPower = linearPower;
        } else {
            double angularPower = GetPIDOutputAngular(desiredAngle);
            ltPower = turnSpeed*0.5 + linearPower*0.5;
            rtPower = turnSpeed*0.5 + linearPower*0.5;
        }
        try{
            LtDriveMain.set(ltPower);
            LtDriveMain.set(ltPower);
            RtDriveMain.set(rtPower);
            RtDriveMain.set(rtPower);
        }catch (Exception e){
            System.out.println(e);
        }
    }
    
    
    public void Rotate(double angularPower){
    
    /*
    To use during autonomous, use GetPIDOutputAngular(desiredAngle)
    To use during teleop, use JoystickMain.getTwist()
    */
    
        try{
            LtDriveMain.set(angularPower);
            LtDriveSub.set(angularPower);
            RtDriveMain.set(-angularPower);
            RtDriveSub.set(-angularPower);
        }catch (Exception e){
            System.out.println(e);
        }
    }
        
    private int sign(double number){
        
    /*
    Helper Function. Returns the sign of a number. Positive numbers return 1.
    Negative numbers return -1. Zero returns zero.
    */
    
        if (number > 0){
            return 1;
        }else if (number < 0){
            return -1;
        } else {
            return 0;
        }
    }
} 

/*----------------------------------------------------------------------------*/
/* Copyright (c) FIRST 2008. All Rights Reserved.                             */
/* Open Source Software - may be modified and shared by FRC teams. The code   */
/* must be accompanied by the FIRST BSD license file in the root directory of */
/* the project.                                                               */
/*----------------------------------------------------------------------------*/

package edu.wpi.first.wpilibj.templates;

import edu.wpi.first.wpilibj.IterativeRobot;

import NerdHerd.Sensor.NerdyCompass;
import NerdHerd.Sensor.NerdyGyro;
import NerdHerd.Sensor.NerdyAccel;
import com.sun.squawk.util.MathUtils;
import edu.wpi.first.wpilibj.Victor;
import edu.wpi.first.wpilibj.Joystick;



/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
public class NerdyPIDRobot extends IterativeRobot{

    private double tolerance;
    private double heading, error, desiredAngle;
    private double turnSpeed, joystickYMagnitude, ltPower, rtPower;
    private double headingOffset = 0;
    private NerdyCompass Compass;
    private NerdyAccel Accel;
    private NerdyGyro Gyro;
    private Joystick JoystickMain;
    private Victor LtDriveMain, LtDriveSub, RtDriveMain, RtDriveSub;
            
    public void init(){
        LtDriveMain = new Victor(1);
        LtDriveSub = new Victor(3);
        RtDriveMain = new Victor(2);
        RtDriveSub = new Victor(4);
        
        JoystickMain = new Joystick(1);
        
        Compass.init();
        Accel.init();
        Gyro.init();
        
        Compass.read();
        Accel.read();
        Gyro.read();
        
        headingOffset = calcHeadingNTC();
    }
    
    public void setTolerance(double degree){
        tolerance = degree;
    }
    
    public double getTolerance(){
        return tolerance;
    }
    
    public boolean isHeadingTolerable(double desiredAngle){
        getHeading();
        return ((desiredAngle < heading+tolerance) && (desiredAngle > heading-tolerance));
    }
    
    public double getHeading(){
        return heading;
    }
    
    public double get360JoystickAngle(){
        double y = JoystickMain.getY();
        double x = JoystickMain.getX();
        double angle = Math.atan(x/y) * 180 / Math.PI;  
        if (x >= 0){
            if (y >= 0){
                angle = 360 - angle;
            } else {
                angle = 180 - angle;
            }
        } else {
            if (y >= 0){
                angle = -angle;
            } else {
                angle = 180 - angle; 
            }
        }
        return angle%360;
    }
    
    private double calcHeadingNTC(){//Non-Tilt Compensated
        Accel.read();
        Compass.read();
        int xAxisCompass = Compass.getAxisX();
        int yAxisCompass = Compass.getAxisY();
        heading = MathUtils.atan(yAxisCompass/xAxisCompass) - headingOffset;
        return heading;
    }
    
    private double calcHeadingTC(){  
        Accel.read();
        Compass.read();
        int xAxisAccel = Accel.getAxisX();
        int yAxisAccel = Accel.getAxisY();
        int xAxisCompass = Compass.getAxisX();
        int yAxisCompass = Compass.getAxisY();
        int zAxisCompass = Compass.getAxisZ();
        
        double pitch = MathUtils.asin(yAxisAccel);
        double roll = MathUtils.asin(xAxisAccel);
        double CMy = xAxisCompass*Math.cos(pitch) + zAxisCompass*Math.sin(pitch);
        double CMx = xAxisCompass*Math.sin(roll) + yAxisCompass*Math.sin(roll)*Math.cos(roll) - zAxisCompass*Math.sin(roll)*Math.cos(pitch);
        heading = MathUtils.atan(CMy/CMx) - headingOffset;
        return heading;
    }

    private boolean isCWShorter(){
        double CWDistance = Math.abs(heading - desiredAngle);
        double CCWDistance = 360 - Math.abs(heading - desiredAngle);
        if (CWDistance <= CCWDistance){
            error = CWDistance;
           return true;
        }else{
            error = -CCWDistance;
            return false;
        }
    }   
    
    public double GetPIOutput(){
        return 0;
        
    }
    
    public void MoveAndRotate(){
        desiredAngle = get360JoystickAngle();
        joystickYMagnitude = JoystickMain.getY();
        if (isHeadingTolerable(desiredAngle)){
            ltPower = joystickYMagnitude;
            rtPower = joystickYMagnitude;
        } else {
            isCWShorter();
            turnSpeed = GetPIOutput();
            ltPower = turnSpeed*0.5 + joystickYMagnitude*0.5;
            rtPower = turnSpeed*0.5 - joystickYMagnitude*0.5;
        }
        LtDriveMain.set(ltPower);
        LtDriveMain.set(ltPower);
        RtDriveMain.set(rtPower);
        RtDriveMain.set(rtPower);
    }
    
    public void Rotate(){
        turnSpeed = JoystickMain.getTwist();
        
        
    }
    
}
